

# 矩阵快速幂

一个简单而熟悉的问题

斐波那契数列满足$f(1)=1,f(2)=1$

当$n \geq $3时，$f(n)=f(n-1)+f(n-2)$

求斐波那契数列的第$n$项$(1 \leq n \leq 10^{18} )$

## 矩阵乘法



![image-20220712153930409](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220712153930409.png)

形象的，A中第i行与B中第j列的数，依次相乘并相加，得到c~ij~

![image-20220712153651035](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220712153651035.png)

## 快速幂

普通的快速幂：

求$a^n$

其核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。

```c++
long long quickPow(long long a, long long n){
    long long ans = 1;
    while(n>0)
    {
        if(n&1>0)        //如果n的当前末位为1(二进制)
            ans *= a;    //ans乘上当前的a
        a *= a;          //a自乘
        n >>= 1;         //n往右移一位,表示除以2
    }
    return ans;
}
```

矩阵快速幂：

求矩阵$A^n$

```c++
struct matrix {
    static const int N = 10;// 所有矩阵都是 N * N 的矩阵
    int a[N][N];
    matrix matrix_mul(matrix A, matrix B, int mod) 
    {   // 2个矩阵相乘
        matrix C;
        for (int i = 0; i < N; i++) 
        {
            for (int j = 0; j < N; j++) 
            {
                C.a[i][j] = 0;
                for (int k = 0; k < N; k++) 
                {
                    C.a[i][j] = (C.a[i][j] + A.a[i][k] * B.a[k][j] % mod) % mod;
                }
            }
        }
        return C;
    }
    matrix unit()// 返回一个单位矩阵
    {
        matrix res;
        for (int i = 0; i < N; i++) 
        {
            for (int j = 0; j < N; j++) 
            {
                if (i == j) res.a[i][j] = 1;
                else res.a[i][j] = 0;
            }
        }
        return res;
    }
    matrix matrix_pow(matrix A, int n, int mod) 
    {
        // 快速求矩阵 A 的 n 次方
        matrix res = unit();
        while (n > 0)
        {
            if (n & 1)                         //如果n的当前末位为1(二进制)
                res = matrix_mul(res, A, mod); //res乘上当前的A
            A = matrix_mul(A, A, mod);         //A自乘
            n >>= 1;                           //n往右移一位,表示除以2
        }
        return res;
    }
};
```

那么这个算法的复杂度级别是$O(N^3logn)$，其中$N$为常数，因此整体算法复杂度为$O(logn)$

## 矩阵A的求解

先回到上面的问题，求斐波那契而数列的第n项
$$
\left[\begin{matrix}
1 & 1\\
1 & 0
\end{matrix}\right]
·
\left[\begin{matrix}
F_n \\
F_{n-1} 
\end{matrix}\right]
=
\left[\begin{matrix}
F_n+F_{n-1} \\
F_n 
\end{matrix}\right]
=
\left[\begin{matrix}
F_{n+1} \\
F_n 
\end{matrix}\right]
$$
以此类推我们得到
$$
\left[\begin{matrix}
F_{n} \\
F_{n-1} 
\end{matrix}\right]
=
\left[\begin{matrix}
1 & 1\\
1 & 0
\end{matrix}\right]
^{n-1}
·
\left[\begin{matrix}
F_1 \\
F_{0} 
\end{matrix}\right]
$$
其他矩阵的求解：

递推式1：$F_i=a×F_{i-1}+b×F_{i-2}$，即二阶线性递推数列
$$
\left[\begin{matrix}a & b\\1 & 0\end{matrix}\right]·\left[\begin{matrix}F_n \\F_{n-1} \end{matrix}\right]=\left[\begin{matrix}a·F_n+b·F_{n-1} \\F_n \end{matrix}\right]=\left[\begin{matrix}F_{n+1} \\F_n \end{matrix}\right]
$$
即
$$
\left[\begin{matrix}F_{n} \\F_{n-1} \end{matrix}\right]=\left[\begin{matrix}a & b\\1 & 0\end{matrix}\right]^{n-1}·\left[\begin{matrix}F_1 \\F_{0} \end{matrix}\right]
$$
递推式2：$F_i=a×F_{i-1}+i^2$
$$
\left[\begin{matrix}
a&1&0&0\\
0&1&2&1\\
0&0&1&1\\
0&0&0&1
\end{matrix}\right]^i
·
\left[\begin{matrix}
F_0 \\1\\1\\1 
\end{matrix}\right]
=
\left[\begin{matrix}
a&1&0&0\\
0&1&2&1\\
0&0&1&1\\
0&0&0&1
\end{matrix}\right]
·
\left[\begin{matrix}
F_{i-1} \\i^2\\i\\1 
\end{matrix}\right]
=
\left[\begin{matrix}
F_{i} \\(i+1)^2\\i+1\\1 
\end{matrix}\right]
$$
递推式3：$F_i=a×F_{i-1}+i^3$
$$
\left[\begin{matrix}
a&1&0&0&0\\
0&1&3&3&1\\
0&0&1&2&1\\
0&0&0&1&1\\
0&0&0&0&1
\end{matrix}\right]^i
·
\left[\begin{matrix}
F_0 \\1\\1\\1 \\1
\end{matrix}\right]
=
\left[\begin{matrix}
a&1&0&0&0\\
0&1&3&3&1\\
0&0&1&2&1\\
0&0&0&1&1\\
0&0&0&0&1
\end{matrix}\right]
·
\left[\begin{matrix}
F_{i-1} \\i^3\\i^2\\i\\1 
\end{matrix}\right]
=
\left[\begin{matrix}
F_{i}\\(i+1)^3 \\(i+1)^2\\i+1\\1 
\end{matrix}\right]
$$
递推式1，2，3总结：$F_i=a×F_{i-1}+b×F_{i-2}+c×i^3+d×i^2+e×i+f$
$$
\left[\begin{matrix}
a&b&c&d&e&f\\
1&0&0&0&0&0\\
0&0&1&3&3&1\\
0&0&0&1&2&1\\
0&0&0&0&1&1\\
0&0&0&0&0&1
\end{matrix}\right]^{i-1}
·
\left[\begin{matrix}
F_1\\F_0 \\i^3\\i^2\\i\\1 
\end{matrix}\right]
=
\left[\begin{matrix}
a&b&c&d&e&f\\
1&0&0&0&0&0\\
0&0&1&3&3&1\\
0&0&0&1&2&1\\
0&0&0&0&1&1\\
0&0&0&0&0&1
\end{matrix}\right]
·
\left[\begin{matrix}
F_{i-1} \\ F_{i-2}\\i^3\\i^2\\i\\1 
\end{matrix}\right]
=
\left[\begin{matrix}
F_{i}\\F_{i-1}\\(i+1)^3 \\(i+1)^2\\i+1\\1 
\end{matrix}\right]
$$


如果有四次方，则插入$(x+1)^4$的系数,以此类推

递推式4：$F_i=a×F_{i-1}+b^i$
$$
\left[\begin{matrix}
a & 1\\
0 & b
\end{matrix}\right]
·
\left[\begin{matrix}
F_0 \\
b
\end{matrix}\right]
=
\left[\begin{matrix}
a & 1\\
0 & b
\end{matrix}\right]
·
\left[\begin{matrix}
F_{i-1} \\
b^i
\end{matrix}\right]
=
\left[\begin{matrix}
F_i \\
b^{i+1}
\end{matrix}\right]
$$
我们对第一个问题进一步改进，求斐波那契而数列数列的前n项和，应该怎么做？

跟上面一样配出来即可

$S_n=S_{n-1}+F_n=S_{n-1}+F_{n-1}+F_{n-2}$
$$
\left[\begin{matrix}
S_n\\
F_{n} \\
F_{n-1} 
\end{matrix}\right]
=
\left[\begin{matrix}
1 & 1 & 1\\
0 & 1 & 1\\
0 & 1 & 0
\end{matrix}\right]
·
\left[\begin{matrix}
S_{n-1}\\
F_{n-1} \\
F_{n-2} 
\end{matrix}\right]
=
\left[\begin{matrix}
1 & 1 & 1\\
0 & 1 & 1\\
0 & 1 & 0
\end{matrix}\right]
^{n-1}
·
\left[\begin{matrix}
S_{1}\\
F_{1} \\
F_{0} 
\end{matrix}\right]
$$

## 矩阵前n项和

给定一个$n×n$的矩阵$A$，求$S=A+A^2+...+A^k$

由等比矩阵的性质：
$$
\left[\begin{matrix}
A&1\\
0&1
\end{matrix}\right]
^n=
\left[\begin{matrix}
A^n&1+A^1+A^2+...A^{n-1}\\
0&1
\end{matrix}\right]
$$
同理构造矩阵：
$$
\left[\begin{matrix}
A&E\\
0&E
\end{matrix}\right]
^n=
\left[\begin{matrix}
A^n&E+A^1+A^2+...A^{n-1}\\
0&E
\end{matrix}\right]
$$
即构造的矩阵的n+1次方的右上角矩阵减去单位矩阵即所求

还有一种方法是等比序列二分求和

构造矩阵求前n项和代码：

```c++
struct matrix {
    int N;
    ll a[31][31];
    matrix(int N_)
    {
        N = N_;
    }
    matrix matrix_mul(matrix A, matrix B, ll mod)
    {   // 2个矩阵相乘
        matrix C(A.N);
        for (int i = 0; i < A.N; i++)
        {
            for (int j = 0; j < A.N; j++)
            {
                C.a[i][j] = 0;
                for (int k = 0; k < A.N; k++)
                {
                    C.a[i][j] = (C.a[i][j] + A.a[i][k] * B.a[k][j] % mod) % mod;
                }
            }
        }
        return C;
    }
    matrix unit(int n)// 返回一个大小为n×n的单位矩阵
    {
        matrix res(n);
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (i == j) res.a[i][j] = 1;
                else res.a[i][j] = 0;
            }
        }
        return res;
    }
    matrix matrix_pow(matrix A, ll n, ll mod)
    {
        // 快速求矩阵 A 的 n 次方
        matrix res = unit(A.N);
        while (n > 0)
        {
            if (n & 1)                         //如果n的当前末位为1(二进制)
                res = matrix_mul(res, A, mod); //res乘上当前的A
            A = matrix_mul(A, A, mod);         //A自乘
            n >>= 1;                           //n往右移一位,表示除以2
        }
        return res;
    }
    matrix matrix_sum(int n, ll mod)//求E+A^1+A^2+...A^n
    {
        matrix res(N * 2);
        /*
        |A E|       |A^n   E+A^1+A^2+...A^(n-1)|
        |0 E|的n次方=| 0            E           |
        */
        //左上角为原矩阵
        for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < N; j++)
            {
                res.a[i][j] = a[i][j];
            }
        }
        //右上角为单位矩阵
        for (int i = 0; i < N; i++)
        {
            for (int j = N; j < 2 * N; j++)
            {
                if (i == j - N) res.a[i][j] = 1;
                else res.a[i][j] = 0;
            }
        }
        //左下角为0矩阵
        for (int i = N; i < 2 * N; i++)
        {
            for (int j = 0; j < N; j++)
            {
                res.a[i][j] = 0;
            }
        }
        //右下角为单位矩阵
        for (int i = N; i < 2 * N; i++)
        {
            for (int j = N; j < 2 * N; j++)
            {
                if (i == j) res.a[i][j] = 1;
                else res.a[i][j] = 0;
            }
        }
        res = matrix_pow(res, n + 1, mod);
        matrix ans(N);
        for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < N; j++)
            {
                ans.a[i][j] = res.a[i][j + N];
            }
        }
        return ans;
    }
};
```

复杂度是$O((2N)^3logn)$，其中$N$为常数，因此复杂度为$O(logn)$

# 高斯消元

高斯消元是线性代数中的重要算法，常用于解决线性方程组。也可以用来求矩阵的逆等问题。

我们先来回顾一下初等行列变换
1.将某一行乘上一个非零数，解不变
2.交换某两行，解不变
3.将某一行的若干倍加到另一行，解不变 

算法步骤：
1.枚举每一列，找到绝对值最大的一行
2.将该行和第一行交换
3.将该行行首置为一
4.将下面所有行第 i 列置为零

具体步骤：

![image-20220725021222673](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220725021222673.png)

其增广矩阵为

![image-20220725021249200](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220725021249200.png)



从左往右枚举每一列 c：
1.找到当前列绝对值最大的元素所在的行；
2.把这一行换到最上面。这里的最上面指的是还未被消成阶梯型的行中的最上面，不是整个矩阵的最上面一行；
3.将该行乘以一个数，使得第一个元素（非阶梯型算起的第一个元素，是矩阵的第c列）变成1；
4.用这个1，利用该行把该列下面的元素都消成0，注意一行的元素要一起变化。

上面循环执行完后，顺利的话，我们会得到一个上三角形：

![image-20220725021352246](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220725021352246.png)

那存在唯一的解法如下：

1.根据最后一个方程得出$x_n=b_n^{'}$

2.将$x_n$带入到第$n-1$个方程，得出$x_{n-1}=b_{n-1}^{'}-a_{n-1}^{'}x_n$

3.不断的往上带入直到第一个方程，解毕

但有时候不能得到上三角形，只能得到一个类似阶梯型。比如我们现在的 $n=4$的增广矩阵消到这个情况：
$$
\left[\begin{matrix}
1&3&2&4&|&5\\
0&1&0&3&|&4\\
0&0&0&1&|&4\\
0&0&0&4&|&3
\end{matrix}\right]
$$
此时我们准备消第3列,消完之后得到：
$$
\left[\begin{matrix}
1&3&2&4&|&5\\
0&1&0&3&|&4\\
0&0&0&1&|&\frac{3}{4}\\
0&0&0&0&|&\frac{15}{4}
\end{matrix}\right]
$$
只要中间有一次整列都是$0$，那最后底下就会多出一行系数全是$0$的方程（比如这里在消第3列的时候出现全是$0$的情况，所以最后一行对应出现一个系数全为$0$的方程）。我们要检查底下的所有系数全是$0$的方程。

如果出现一次诸如 $0=15/4$，那方程直接无解。因为这个方程永远无法满足；
如果所有方程都是 $0 = 0$，那说明有无效不矛盾方程，方程有无穷解。

浮点模板

```c++
const int N = 300;
const double eps = 1e-6;
int n;
double a[N][N];
int gauss()
{
    int c, r; // column, row
    for (c = 0, r = 0; c < n; c++)
    {
        int t = r;   // 从对角线元素开始往下遍历这一列
        for (int i = t; i < n; i++) // 找到该列绝对值最大的元素所在的行号
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;

        if (fabs(a[t][c]) < eps) continue; // 最大绝对值是0，那么这一列剩下的元素全是0，不用管这列。这个地方导致后面不能r ++，也意味着底部将会增加一个系数全0的方程

        for (int i = c; i <= n; i++) swap(a[t][i], a[r][i]); // 把最大绝对值元素所在的行换到未处理行的最上面(即当前要处理的的第r行)
        for (int i = n; i >= c; i--) a[r][i] /= a[r][c];  // 把现在的第r行的数字全部除以一个系数，使得左上角a[r][c]变成1
        for (int i = r + 1; i < n; i++) // 把当前列下的所有数都消成0,要对应两行元素一起变化
            if (fabs(a[i][c]) > eps) //已经是0的就不用操作了，省点计算
                for (int j = n; j >= c; j--)
                    a[i][j] -= a[r][j] * a[i][c];

        r++;
    }

    // 上面步骤走完之后，矩阵a[][]扣掉增广的最后一列系数以外，剩下的已经是个上三角阵或者阶梯阵
    if (r < n) // 说明有效的方程个数小于n,那要么无穷解，要么无解
    {
        for (int i = r; i < n; i++) {
            if (fabs(a[i][n]) > eps) // a[i][n] = b_i不等于0
                return 2;  // 无解
            return 1;  // 都是0 = 0的方程，无穷解
        }
    }

    // 唯一解，从下往上回代，得到方程的解
    for (int i = n - 1; i >= 0; i--)
        for (int j = i + 1; j < n; j++)
            a[i][n] -= a[i][j] * a[j][n];

    return 0;
}


int main() {
    cin >> n;

    for (int i = 0; i < n; i++)
        for (int j = 0; j <= n; j++)
            cin >> a[i][j];

    int t = gauss();

    if (t == 0)
        for (int i = 0; i < n; i++) printf("%.2f\n", a[i][n]);
    else if (t == 1) puts("Infinite group solutions");
    else puts("No solution");

    return 0;
}

```

整数模板

```c++
typedef long long ll;
const int MOD = 7;
const int N = 300;
int a[N][N];
int x[N];//解集
bool free_x[N];//标记是否是不确定的变元

inline int gcd(int a, int b)
{
    int t;
    while (b != 0)
    {
        t = b;
        b = a % b;
        a = t;
    }
    return a;
}
inline int lcm(int a, int b)
{
    return a / gcd(a, b) * b;//先除后乘防止溢出
}
//高斯消元法接方程组。(-2表示有浮点数解,但无整数解,-1表示无解,
//0表示唯一解,大于0表示无穷解,并返回自由变元的个数)
//有equ个方程,var个变元。增广矩阵行数为equ,分别为0到equ-1,列数为var+1,分别为0到var
int Gauss(int equ, int var)
{
    int i, j, k;
    int max_r;//当前这列绝对值最大的行
    int col;//当前处理的列
    int ta, tb;
    int LCM;
    int temp;
    int free_x_num;
    int free_index;

    for (int i = 0; i <= var; i++)
    {
        x[i] = 0;
        free_x[i] = true;
    }
    //转换为阶梯阵
    col = 0;//处理当前的列
    for (k = 0; k < equ && col < var; k++, col++)
    {//枚举当前处理的行,找到该col列元素绝对值最大的那行与第k行交换.(为了在除法时减小误差)
        max_r = k;
        for (i = k + 1; i < equ; i++)
        {
            if (abs(a[i][col]) > abs(a[max_r][col])) max_r = i;
        }
        if (max_r != k)
        {//与第k行交换
            for (j = k; j < var + 1; j++) swap(a[k][j], a[max_r][j]);
        }
        if (a[k][col] == 0)
        {//说明该col列第k行一下全是0了,则处理当前行的下一列
            k--;
            continue;
        }
        for (i = k + 1; i < equ; i++)
        {//枚举要删去的行
            if (a[i][col] != 0)
            {
                LCM = lcm(abs(a[i][col]), abs(a[k][col]));
                ta = LCM / abs(a[i][col]);
                tb = LCM / abs(a[k][col]);
                if (a[i][col] * a[k][col] < 0) tb = -tb;//异号的情况是相加
                for (j = col; j < var + 1; j++)
                {
                    a[i][j] = ((a[i][j] * ta - a[k][j] * tb) % MOD + MOD) % MOD;
                }
            }
        }
    }
    //1.无解的情况：化简的增广阵中存在(0,0,...,a)这样的行(a!=0)
    for (i = k; i < equ; i++)
    {//对于无穷解来说,如果要判断哪些是自由变元,那么初等行变换中的交换就会影响,则要记录交换
        if (a[i][col] != 0) return -1;
    }
    //2.无穷解的情况：在var*(var+1)的增广阵中出现(0,0,...,0)这样的行,说明没有形成严格的上三角阵
    //且出现的行数即为自由变元的个数
    if (k < var)
    {
        //首先自由变元有(var-k)个,即不确定的变元至少有(var-k)个
        for (i = k - 1; i >= 0; i--)
        {
            //第i行一定不会是(0,0,...,0)的情况,因为这样的行是在第k行到第equ行
            //同样,第i行一定不会是(0,0,...,a),a!=0的情况,这样的无解的
            free_x_num = 0;//用于判断该行中不确定的变元的合数,如果超过1个,则无法求解,他们仍然为不确定的变元
            for (j = 0; j < var; j++)
            {
                if (a[i][j] != 0 && free_x[j]) free_x_num++, free_index = j;
            }
            if (free_x_num > 1) continue;//无法求解出确定的变元
            //说明就只有一个不确定的变元free_index,那么可以求解出该变元,且该变元是确定的
            temp = a[i][var];
            for (j = 0; j < var; j++)
            {
                if (a[i][j] != 0 && j != free_index) temp -= a[i][j] * x[j] % MOD;
                //temp -= (temp%MOD+MOD)%MOD;
            }
            //while(temp%a[i][free_index]!=0) temp+=MOD;
            x[free_index] = (temp / a[i][free_index]) % MOD;//求出该变元
            free_x[free_index] = 0;//该变元是确定的
        }
        return (var - k);//自由变元有(var-k)个
    }
    //3.唯一解的情况：在var*(var+1)的增广阵中形成严格的上三角阵
    //计算出Xn-1,Xn-2,...,X0
    for (i = var - 1; i >= 0; i--)
    {
        temp = a[i][var];
        for (j = i + 1; j < var; j++)
        {
            if (a[i][j] != 0) temp -= a[i][j] * x[j];
            //temp = (temp%MOD+MOD)%MOD;
        }
        //while(temp%a[i][i]!=0)//外层每次循环都是求a[i][i]，它是每个方程中唯一一个未知的变量
        //temp+=MOD;//a[i][i]必须为整数，加上周期MOD
        if (temp % a[i][i] != 0) return -2;
        x[i] = temp / a[i][i];
    }
    return 0;
}
int main()
{
    int i, j;
    int equ, var;
    while (scanf("%d %d", &equ, &var) != EOF)
    {
        memset(a, 0, sizeof(a));
        for (i = 0; i < equ; i++)
        {
            for (j = 0; j < var + 1; j++)
            {
                scanf("%d", &a[i][j]);
            }
        }
        int free_num = Gauss(equ, var);
        if (free_num == -1) printf("No solution\n");
        else if (free_num == -2) printf("Float but no int solution\n");
        else if (free_num > 0)
        {
            printf("Infinite solution,自由变元个数为%d\n", free_num);
            for (i = 0; i < var; i++)
            {
                if (free_x[i]) printf("x%d 是不确定的\n", i + 1);
                else printf("x%d: %d\n", i + 1, x[i]);
            }
        }
        else
        {
            for (i = 0; i < var; i++)
            {
                printf("x%d: %d\n", i + 1, x[i]);
            }
        }
        printf("\n");
    }
    return 0;
}
```

01矩阵模板

```c
const int N = 300;
int a[N][N];
int Free_x[N];   //自由变元
int x[N];  //解集 
int Free_num = 0;  //自由变元数
int Guass(int Row, int Column)  //系数矩阵的行和列
{
	int row = 0, col = 0, max_r;
	Free_num = 0;
	for (row = 0; row < Row && col < Column; row++, col++)
	{
		max_r = row;
		for (int i = row + 1; i < Row; i++)   //找出当前列最大值
			if (abs(a[i][col]) > abs(a[max_r][col]))
				max_r = i;
		if (a[max_r][col] == 0)  //记录自由变元
		{
			row--;
			Free_x[Free_num++] = col + 1;
			continue;
		}
		if (max_r != row)  //交换
			for (int i = col; i < Column + 1; i++)
				swap(a[row][i], a[max_r][i]);
		for (int i = row + 1; i < Row; i++)   //消元
		{
			if (a[i][col] != 0)
			{
				for (int j = col; j < Column + 1; j++)
					a[i][j] ^= a[row][j];
			}
		}
	}
	for (int i = row; i < Row; i++)   //无解
		if (a[i][Column] != 0)
			return -1;
	if (row < Column)   //无穷多解
		return Column - row;
	//唯一解
	for (int i = Column - 1; i >= 0; i--)
	{
		x[i] = a[i][Column];
		for (int j = i + 1; j < Column; j++)
			x[i] ^= (a[i][j] && x[j]);
	}
	return 0;
}

```

其算法复杂度为$O(n^3)$

| 题目序号 | 题目出处 | 题目类型 | 题目难度 |
| -------- | -------- | -------- | -------- |
| 1        | 洛谷p1962 | 矩阵快速幂模板 | ⭐        |
| 2       | HDU1575 | 矩阵快速幂模板 | ⭐ |
| 3        | POJ 3233 | 矩阵快速幂矩阵前n项和 | ⭐⭐ |
| 4        | HDU 2254 | 矩阵快速幂矩阵前n项和 | ⭐⭐⭐ |
| 5    | HDU 1588  | 矩阵快速幂矩阵前n项和 | ⭐⭐⭐⭐ |
| 6        | HDU 1757 | 矩阵快速幂矩阵构造 | ⭐⭐ |
| 7        | HDU 2276 | 矩阵快速幂矩阵构造 | ⭐⭐⭐⭐ |
| 8        | HDU 2256 | 矩阵快速幂矩阵构造 | ⭐⭐⭐⭐ |
| 9 | 洛谷P3389 | 高斯消元浮点模板 | ⭐ |
| 10 | POJ 1222 | 高斯消元01矩阵列方程组 | ⭐⭐⭐ |
| 11 | POJ 2065 | 高斯消元整数矩阵列同余方程组 | ⭐⭐⭐ |
| 12 | POJ 1681 | 高斯消元01矩阵枚举自由元 | ⭐⭐⭐⭐ |
| 13 | POJ 1753 | 高斯消元01矩阵枚举自由元 | ⭐⭐⭐⭐ |
| 14 |          |          |          |
| 15 |          |          |          |
| 16 |          |          |          |
| 17 |          |          |          |
| 18 |          |          |          |
| 19 |          |          |          |
| 20 |          |          |          |
| 21 |          |          |          |
| 22 |          |          |          |
| 23 |          |          |          |
| 24 |          |          |          |
| 25 |          |          |          |
| 26 |          |          |          |
| 27 |          |          |          |
